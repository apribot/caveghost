<!DOCTYPE html>
<html>

<head>
    <title></title>
    <script>
        /*





        -- TODO ---------------
        ------------------------

        [nuts and bolts]
         	- create more random cave features
         	- make a start screen
         	- add holes in floor that reveal stars/space
        [conceptual]


        */



        // http://patorjk.com/software/taag/#p=display&f=ANSI%20Shadow&t=VARS


        //dialogs['firefly'] = false;

        /*

        ██╗  ███╗   ██╗  ██╗ ████████╗
        ██║  ████╗  ██║  ██║ ╚══██╔══╝
        ██║  ██╔██╗ ██║  ██║    ██║   
        ██║  ██║╚██╗██║  ██║    ██║   
        ██║  ██║ ╚████║  ██║    ██║   
        ╚═╝  ╚═╝  ╚═══╝  ╚═╝    ╚═╝   


        */

        document.addEventListener("DOMContentLoaded", function(event) {
            canv = document.getElementById("canv");
            context = canv.getContext("2d");

            canv.setAttribute('width', mapWidth * blocksize);
            canv.setAttribute('height', mapHeight * blocksize);

            // init sequence

            // generate cave matrix
            cave.RandomFillmap();
            cave.MakeCaverns();

            // clone up some shrooms and initialize them	
            for (var i = 0; i < shrooms; i++) {
                shroom_dad[i] = clone(shroom);
                shroom_dad[i].start();
            };

            // initialize PC
            dude.start();

            portal.start();
            // initialize fireflies		
            for (var i = 0; i < bugs; i++) {
                bug_dad[i] = clone(bug);
                bug_dad[i].start();
            };

            // start up big timer
            resume();

            //start musics
            bgmusic.play({loop:true});

        });

        function clone(obj) {
            if (obj == null || typeof(obj) != 'object')
                return obj;

            var temp = obj.constructor(); // changed

            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    temp[key] = clone(obj[key]);
                }
            }
            return temp;
        }


CanvasRenderingContext2D.prototype.wrapText = function (text, x, y, maxWidth, lineHeight) {

    var lines = text.split("\n");

    for (var i = 0; i < lines.length; i++) {

        var words = lines[i].split(' ');
        var line = '';

        for (var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + ' ';
            var metrics = this.measureText(testLine);
            var testWidth = metrics.width;
            if (testWidth > maxWidth && n > 0) {
                this.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            }
            else {
                line = testLine;
            }
        }

        this.fillText(line, x, y);
        y += lineHeight;
    }
}

        /*

         ██████╗ █████╗ ██╗   ██╗███████╗     ██████╗ ██████╗      ██╗
        ██╔════╝██╔══██╗██║   ██║██╔════╝    ██╔═══██╗██╔══██╗     ██║
        ██║     ███████║██║   ██║█████╗      ██║   ██║██████╔╝     ██║
        ██║     ██╔══██║╚██╗ ██╔╝██╔══╝      ██║   ██║██╔══██╗██   ██║
        ╚██████╗██║  ██║ ╚████╔╝ ███████╗    ╚██████╔╝██████╔╝╚█████╔╝
         ╚═════╝╚═╝  ╚═╝  ╚═══╝  ╚══════╝     ╚═════╝ ╚═════╝  ╚════╝ 
                                                                      

        */
        var cave = {
            wallheight: 10,
            MakeBG: function() {
                context.fillStyle = "#9ab";
                context.fillRect(0, 0, mapWidth * blocksize, mapHeight * blocksize);
            },
            MakeCaverns: function() {
                for (itteration = 0; itteration <= maxitteration; itteration++) {
                    for (var row = 0; row <= mapHeight; row++) {
                        for (var column = 0; column <= mapWidth; column++) {
                            map[column][row] = this.PlaceWallLogic(column, row);
                        }
                    }
                }
            },

            RandomFillmap: function() {
                var mapMiddle = 0;
                var column;
                var row;

                for (column = 0; column <= mapWidth; column++) {
                    // add new dimension
                    map[column] = new Array();
                    mapMiddle = (mapHeight / 2);
                    for (row = 0; row <= mapHeight; row++) {
                        if (column == 0 && row >= mapMiddle + 10 && row <= mapMiddle - 10) {
                            map[column][row] = 1;
                        } else if (row == 0) {
                            map[column][row] = 1;
                        } else if (column == mapWidth - 1 && row >= mapMiddle + 10 && row <= mapMiddle - 10) {
                            map[column][row] = 1;
                        } else if (row == mapHeight - 1) {
                            map[column][row] = 1;
                        }
                        // Else, fill with a wall a random percent of the time
                        else {
                            if (row <= mapMiddle + 2 && row >= mapMiddle - 2) {
                                map[column][row] = 0;
                            } else {
                                map[column][row] = this.RandomPercent(PercentAreWalls);
                            }
                        }
                    };
                };
            },

            RandomPercent: function(percent) {
                if (percent >= (Math.random() * 101) + 1) {
                    return 1;
                }
                return 0;
            },

            PlaceWallLogic: function(x, y) {
                var numWalls = this.GetAdjacentWalls(x, y, 1, 1);

                if (map[x][y] == 1) {
                    if (numWalls >= 4) {
                        return 1;
                    }
                    if (numWalls < 2) {
                        return 0;
                    }
                } else {
                    if (numWalls >= 5) {
                        return 1;
                    }
                }
                return 0;
            },

            GetAdjacentWalls: function(x, y, scopeX, scopeY) {
                var startX = x - scopeX;
                var startY = y - scopeY;
                var endX = x + scopeX;
                var endY = y + scopeY;

                var iX = startX;
                var iY = startY;

                var wallCounter = 0;

                for (iY = startY; iY <= endY; iY++) {
                    for (iX = startX; iX <= endX; iX++) {
                        if (!(iX == x && iY == y)) {
                            if (this.IsWall(iX, iY)) {
                                wallCounter += 1;
                            }
                        }
                    }
                }
                return wallCounter;
            },

            IsWall: function(x, y) {
                // Consider out-of-bound a wall
                if (this.IsOutOfBounds(x, y)) {
                    return true;
                }

                if (map[x][y] == 1) {
                    return true;
                }

                if (map[x][y] == 0) {
                    return false;
                }
                return false;
            },

            IsOutOfBounds: function(x, y) {
                if (x < 0 || y < 0) {
                    return true;
                } else if (x > mapWidth - 1 || y > mapHeight - 1) {
                    return true;
                }
                return false;
            },

            printmap: function() {
                var outp = '';
                for (var y = 0; y <= mapHeight; y++) {
                    for (var x = 0; x <= mapWidth; x++) {
                        if (map[x][y] == 1) {
                            context.fillStyle = "#000";
                            context.fillRect(x * blocksize - this.wallheight, y * blocksize - this.wallheight, blocksize, blocksize);

                        }
                    };
                };
            },


            printwall: function() {
                var outp = '';
                for (var y = 0; y <= mapHeight; y++) {
                    for (var x = 0; x <= mapWidth; x++) {
                        if (map[x][y] == 1) {


                            // performance fix, babbyyy

                            if (map[x][y + 1] == 0 || (x < mapWidth && map[x + 1][y] == 0)) {
                                context.fillStyle = "#234";

                                context.beginPath();
                                context.moveTo((x * blocksize) + blocksize, (y * blocksize) + blocksize);
                                context.lineTo((x * blocksize), (y * blocksize) + blocksize);
                                context.lineTo((x * blocksize) - this.wallheight, (y * blocksize) + blocksize - this.wallheight);
                                context.lineTo((x * blocksize) + blocksize - this.wallheight, (y * blocksize) + blocksize - this.wallheight);
                                context.lineTo((x * blocksize) + blocksize - this.wallheight, (y * blocksize) - this.wallheight);
                                context.lineTo((x * blocksize) + blocksize, (y * blocksize));
                                context.lineTo((x * blocksize) + blocksize, (y * blocksize) + blocksize);
                                context.fill();
                            }


                        }
                    };
                };
            },


            getStartPos: function() {
                var pos = new Array();
                for (var x = 2; x <= mapWidth; x++) {
                    if (map[x][Math.floor(mapHeight / 2)] == 0) {
                        pos['x'] = x;
                        pos['y'] = Math.floor(mapHeight / 2);
                        return pos;
                    }
                };
            },

            getStartPosR: function() {
                var pos = new Array();
                for (var x = mapWidth - 2; x >= 2; x++) {
                    if (map[x][Math.floor(mapHeight / 2)] == 0) {
                        pos['x'] = x;
                        pos['y'] = Math.floor(mapHeight / 2);
                        return pos;
                    }
                };
            },

            getRandPos: function() {
                var pos = new Array();
                var i = 0;
                for (var x = 0; x <= mapWidth; x++) {
                    for (var y = 0; y <= mapHeight; y++) {
                        if (map[x][y] == 0) {
                            pos[i] = new Array();
                            pos[i]['x'] = x;
                            pos[i]['y'] = y;
                            i++;
                        }
                    };
                };

                var ret = pos[Math.floor(Math.random() * pos.length)]
                return ret;
            }
        };

        /*
        ██╗    ██╗ ██████╗ ██████╗ ██╗     ██████╗      ██████╗ ██████╗      ██╗
        ██║    ██║██╔═══██╗██╔══██╗██║     ██╔══██╗    ██╔═══██╗██╔══██╗     ██║
        ██║ █╗ ██║██║   ██║██████╔╝██║     ██║  ██║    ██║   ██║██████╔╝     ██║
        ██║███╗██║██║   ██║██╔══██╗██║     ██║  ██║    ██║   ██║██╔══██╗██   ██║
        ╚███╔███╔╝╚██████╔╝██║  ██║███████╗██████╔╝    ╚██████╔╝██████╔╝╚█████╔╝
         ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═════╝      ╚═════╝ ╚═════╝  ╚════╝ 
                                                                                
        */

        var world = {
            pos: 0,
            mapqty: 0,
            map: [],
            setMap: function(ar) {
                this.map[this.pos] = ar;
                this.mapqty = this.map.length;
            },
            getMap: function(id) {
                // default to current pos
                id = id || this.pos;
                return this.map[id]
            }
        };




        /*

        ███████╗ ██████╗ ██████╗ ██████╗ ███████╗     ██████╗ ██████╗      ██╗
        ██╔════╝██╔════╝██╔═══██╗██╔══██╗██╔════╝    ██╔═══██╗██╔══██╗     ██║
        ███████╗██║     ██║   ██║██████╔╝█████╗      ██║   ██║██████╔╝     ██║
        ╚════██║██║     ██║   ██║██╔══██╗██╔══╝      ██║   ██║██╔══██╗██   ██║
        ███████║╚██████╗╚██████╔╝██║  ██║███████╗    ╚██████╔╝██████╔╝╚█████╔╝
        ╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝     ╚═════╝ ╚═════╝  ╚════╝ 
                                                                              
        */

        var score = {
            shrooms: 0,
            fireflies: 0,
            width: 200,
            height: 200,
            x: 300,
            y: 100,
            draw: function() {

                blip.play();
                // inventory box
                
                
                context.strokeStyle = '#abc';
                context.linewidth = 10;
                context.strokeRect(this.x, this.y, this.width, this.height);

                context.fillStyle = "rgba(0,0,0,0.8)";
                context.fillRect(this.x, this.y, this.width, this.height);

                // items title
                context.fillStyle = 'white';
                context.font = "16px Courier New";
                
                context.fillText('ITEMS', this.x + 72, this.y + 20);


                //shrooms
                context.drawImage(shroom_img, this.x + 20, this.y + 50);
                context.fillText(this.shrooms, this.x + 40, this.y + 60);

                //fireflies

                var fireflyx = this.x + 20;
                var fireflyy = this.y + 80;
                var radGrad = context.createRadialGradient(
                    fireflyx + blocksize / 2, fireflyy + blocksize / 2, 10,
                    fireflyx + blocksize / 2, fireflyy + blocksize / 2, 40);
                radGrad.addColorStop(0, "rgba(229,255,160,0.15)");
                radGrad.addColorStop(1, "transparent");

                context.fillStyle = radGrad;
                context.fillRect(0, 0, mapWidth * blocksize, mapHeight * blocksize);

                context.drawImage(bug_img, fireflyx, fireflyy);
                context.fillStyle = 'white';
                context.fillText(this.fireflies, this.x + 40, this.y + 90);
            }
        };


		/*

		██████╗ ██╗ █████╗ ██╗      ██████╗  ██████╗      ██████╗ ██████╗      ██╗
		██╔══██╗██║██╔══██╗██║     ██╔═══██╗██╔════╝     ██╔═══██╗██╔══██╗     ██║
		██║  ██║██║███████║██║     ██║   ██║██║  ███╗    ██║   ██║██████╔╝     ██║
		██║  ██║██║██╔══██║██║     ██║   ██║██║   ██║    ██║   ██║██╔══██╗██   ██║
		██████╔╝██║██║  ██║███████╗╚██████╔╝╚██████╔╝    ╚██████╔╝██████╔╝╚█████╔╝
		╚═════╝ ╚═╝╚═╝  ╚═╝╚══════╝ ╚═════╝  ╚═════╝      ╚═════╝ ╚═════╝  ╚════╝ 

		*/

 		var dialog = {
            width: 200,
            height: 200,
            x: 300,
            y: 100,
            draw: function(txt) {

                blip.play();
                // inventory box
                
                
                context.strokeStyle = '#abc';
                context.linewidth = 10;
                context.strokeRect(this.x, this.y, this.width, this.height);

                context.fillStyle = "rgba(0,0,0,0.8)";
                context.fillRect(this.x, this.y, this.width, this.height);

                // items title
                context.fillStyle = 'white';
                context.font = "16px Courier New";
                
                context.wrapText(txt, this.x + 10, this.y + 20, this.width-20, 16);
                context.fillStyle = '#678';
                context.wrapText('[press spacebar]', this.x + 20, this.y + this.height-20, this.width-20, 16);
            }
        };





        /*

        ███████╗██╗  ██╗██████╗  ██████╗  ██████╗ ███╗   ███╗     ██████╗ ██████╗      ██╗
        ██╔════╝██║  ██║██╔══██╗██╔═══██╗██╔═══██╗████╗ ████║    ██╔═══██╗██╔══██╗     ██║
        ███████╗███████║██████╔╝██║   ██║██║   ██║██╔████╔██║    ██║   ██║██████╔╝     ██║
        ╚════██║██╔══██║██╔══██╗██║   ██║██║   ██║██║╚██╔╝██║    ██║   ██║██╔══██╗██   ██║
        ███████║██║  ██║██║  ██║╚██████╔╝╚██████╔╝██║ ╚═╝ ██║    ╚██████╔╝██████╔╝╚█████╔╝
        ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚═╝     ╚═╝     ╚═════╝ ╚═════╝  ╚════╝ 
                                                                                          

        */

        var shroom = {
            x: "",
            y: "",
            dead: false,
            start: function() {
                var pos = new Array();
                pos = cave.getRandPos();
                this.x = pos['x'];
                this.y = pos['y'];
            },
            draw: function() {
                if (Math.round(dude.x / blocksize) == this.x && Math.round(dude.y / blocksize) == this.y && !this.dead) {
                    this.dead = true;
                    score.shrooms++;
                    pickupsound.play();
                    if( !dialogs['mushroom'] ) {
                        	
                        	dialogs['mushroom'] = true;
                        	setTimeout(function() { pause(); }, 100);

                        	setTimeout(function() { dialog.draw("What a strange mushroom.\n\nIt's...warm."); }, 500);
                        }
                }
                if (!this.dead) {
                    context.drawImage(shroom_img, this.x * blocksize, this.y * blocksize);
                }
            }
        }

        /*

        ██████╗  ██████╗ ██████╗ ████████╗ █████╗ ██╗          ██████╗ ██████╗      ██╗
        ██╔══██╗██╔═══██╗██╔══██╗╚══██╔══╝██╔══██╗██║         ██╔═══██╗██╔══██╗     ██║
        ██████╔╝██║   ██║██████╔╝   ██║   ███████║██║         ██║   ██║██████╔╝     ██║
        ██╔═══╝ ██║   ██║██╔══██╗   ██║   ██╔══██║██║         ██║   ██║██╔══██╗██   ██║
        ██║     ╚██████╔╝██║  ██║   ██║   ██║  ██║███████╗    ╚██████╔╝██████╔╝╚█████╔╝
        ╚═╝      ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚══════╝     ╚═════╝ ╚═════╝  ╚════╝ 

        */
        var portal = {
                x: "",
                y: "",
                off: false,
                dead: false,
                glow: 0.8,
                maxglow: 0.5,
                minglow: 0.1,
                glowup: true,
                start: function() {
                    this.x = dude.x - blocksize;
                    this.y = dude.y - blocksize;
                },
                draw: function() {
                    if (this.dead) {
                        return;
                    }

                    if (dude.x > this.x + 50 || dude.x < this.x - 50 || dude.y < this.y - 50 || dude.y > this.y + 50) {
                        portal_img.src = 'portaldead.png';
                        this.off = true;
                    }

                    context.drawImage(portal_img, this.x, this.y);

                    if( !dialogs['portal'] ) {
                    	
                    	dialogs['portal'] = true;
                    	setTimeout(function() { pause(); }, 100);

                    	setTimeout(function() { dialog.draw("Where am I?\n\nI can barely see.\n\nWhat are those lights...fireflies?"); }, 500);
                    }
                },

                shadow: function() {
                    if (!this.off) {

                        var radGrad = context.createRadialGradient(
                            (this.x) + (blocksize * 1.5), (this.y) + (blocksize * 1.5), 5, (this.x) + (blocksize * 1.5), (this.y) + (blocksize * 1.5), 40);
                        radGrad.addColorStop(0, "rgba(200,255,255," + this.glow + ")");
                        radGrad.addColorStop(1, "transparent");

                        context.fillStyle = radGrad;
                        context.fillRect(0, 0, mapWidth * blocksize, mapHeight * blocksize);

                        if (this.glowup) {
                            this.glow += 0.05;
                        } else {
                            this.glow -= 0.05;
                        }

                        if (this.glow > this.maxglow) {
                            this.glowup = false;
                        }
                        if (this.glow < this.minglow) {
                            this.glowup = true;
                        }
                    }
                }
            }

		/*

		███████╗████████╗ █████╗ ███████╗██╗███████╗     ██████╗ ██████╗      ██╗
		██╔════╝╚══██╔══╝██╔══██╗██╔════╝██║██╔════╝    ██╔═══██╗██╔══██╗     ██║
		███████╗   ██║   ███████║███████╗██║███████╗    ██║   ██║██████╔╝     ██║
		╚════██║   ██║   ██╔══██║╚════██║██║╚════██║    ██║   ██║██╔══██╗██   ██║
		███████║   ██║   ██║  ██║███████║██║███████║    ╚██████╔╝██████╔╝╚█████╔╝
		╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝╚══════╝     ╚═════╝ ╚═════╝  ╚════╝ 
		                                                                         
		*/

        var stasis = {
                x: "",
                y: "",
                off: false,
                start: function() {
                	var pos = new Array();
                	pos = cave.getStartPosR();
                	this.x = (pos['x']-7) * blocksize;
                	this.y = (pos['y']-1) * blocksize;
                },
                draw: function() {
                	if (Math.abs(dude.y - this.y) <= blocksize * 5 && Math.abs(dude.x - this.x) <= blocksize * 5) {

			            if( !dialogs['stasis']) {
				        	
				        	dialogs['stasis'] = true;
				        	setTimeout(function() { pause(); }, 100);
				        	setTimeout(function() { dialog.draw("Stasis...pods...?"); }, 300);
				        }
	                }
                    context.drawImage(stasis_img, this.x, this.y);
                }
            }



            /*

            ██████╗ ██╗   ██╗ ██████╗      ██████╗ ██████╗      ██╗
            ██╔══██╗██║   ██║██╔════╝     ██╔═══██╗██╔══██╗     ██║
            ██████╔╝██║   ██║██║  ███╗    ██║   ██║██████╔╝     ██║
            ██╔══██╗██║   ██║██║   ██║    ██║   ██║██╔══██╗██   ██║
            ██████╔╝╚██████╔╝╚██████╔╝    ╚██████╔╝██████╔╝╚█████╔╝
            ╚═════╝  ╚═════╝  ╚═════╝      ╚═════╝ ╚═════╝  ╚════╝ 
                                                                   
            */
        var bug = {
                x: '',
                y: '',
                goingU: false,
                goingD: false,
                goingL: false,
                goingR: false,
                inertia: {
                    weight: 5,
                    speed: 0,
                    u: false,
                    d: false,
                    l: false,
                    r: false
                },
                increment: 0.5,
                dead: false,

                start: function() {
                    var pos = new Array();
                    pos = cave.getRandPos();
                    this.x = pos['x'] * blocksize;
                    this.y = pos['y'] * blocksize;
                },

                draw: function() {

                    // check if firefly is being picked up
                    if (Math.abs(dude.y - this.y) <= blocksize / 2 && Math.abs(dude.x - this.x) <= blocksize / 2 && !this.dead) {
                        this.dead = true;
                        score.fireflies++;
                        dude.light++;
                        pickupsound.play();
                        if( !dialogs['firefly'] ) {
                        	
                        	dialogs['firefly'] = true;
                        	setTimeout(function() { pause(); }, 100);

                        	setTimeout(function() { dialog.draw("Maybe I can use these fireflies to see better."); }, 500);
                        }
                    }

                    if (this.dead) {
                        return;
                    }
                    // l
                    if (this.goingL && this.x > 1 && map[Math.ceil(this.x / blocksize) - 1][Math.round(this.y / blocksize)] == 0) {
                        this.x -= this.increment;
                        this.inertia.l = true;
                        this.inertia.speed = this.inertia.weight;
                    }

                    // r
                    if (this.goingR && this.x < mapWidth * blocksize && map[Math.floor(this.x / blocksize) + 1][Math.round(this.y / blocksize)] == 0) {
                        this.x += this.increment;
                        this.inertia.r = true;
                        this.inertia.speed = this.inertia.weight;
                    }

                    // u
                    if (this.goingU && this.y > 1 && map[Math.round(this.x / blocksize)][Math.round(this.y / blocksize) - 1] == 0) {
                        this.y -= this.increment;
                        this.inertia.u = true;
                        this.inertia.speed = this.inertia.weight;
                    }

                    // d
                    if (this.goingD && this.y < mapHeight * blocksize && map[Math.round(this.x / blocksize)][Math.floor(this.y / blocksize) + 1] == 0) {
                        this.y += this.increment;
                        this.inertia.d = true;
                        this.inertia.speed = this.inertia.weight;
                    }

                    // residual inertia
                    if (
                        (!this.goingU && !this.goingD && !this.goingL && !this.goingR) && (this.inertia.speed > 0)
                    ) {
                        if (this.inertia.l && this.x > 1 && map[Math.ceil(this.x / blocksize) - 1][Math.round(this.y / blocksize)] == 0) {
                            this.x -= this.inertia.speed;
                        }

                        // r
                        if (this.inertia.r && this.x < mapWidth * blocksize && map[Math.floor(this.x / blocksize) + 1][Math.round(this.y / blocksize)] == 0) {
                            this.x += this.inertia.speed;
                        }

                        // u
                        if (this.inertia.u && this.y > 1 && map[Math.round(this.x / blocksize)][Math.round(this.y / blocksize) - 1] == 0) {
                            this.y -= this.inertia.speed;
                        }

                        // d
                        if (this.inertia.d && this.y < mapHeight * blocksize && map[Math.round(this.x / blocksize)][Math.floor(this.y / blocksize) + 1] == 0) {
                            this.y += this.inertia.speed;
                        }
                        this.inertia.speed--;
                    }
                    if (this.inertia.speed <= 0) {
                        this.inertia.u = false;
                        this.inertia.d = false;
                        this.inertia.l = false;
                        this.inertia.r = false;
                    }
                    context.drawImage(bug_img, this.x, this.y);
                },

                shadow: function() {
                    if (this.dead) {
                        return;
                    }
                    var radGrad = context.createRadialGradient(
                        (this.x) + blocksize / 2, (this.y) + blocksize / 2, 10, (this.x) + blocksize / 2, (this.y) + blocksize / 2, 40);
                    radGrad.addColorStop(0, "rgba(229,255,160,0.15)");
                    radGrad.addColorStop(1, "transparent");

                    context.fillStyle = radGrad;
                    context.fillRect(0, 0, mapWidth * blocksize, mapHeight * blocksize);
                },

                wander: function() {
                    // start random movement
                    var direction = Math.floor(Math.random() * 10);
                    switch (direction) {
                        case 0:
                            this.goingD = false;
                            this.goingU = true;
                            break;
                        case 1:
                            this.goingU = false;

                            this.goingD = true;
                            break;
                        case 2:
                            this.goingR = false;
                            this.goingL = true;
                            break;
                        case 3:
                            this.goingL = false;
                            this.goingR = true;
                            break;
                    }
                    this.draw();
                }
            }
            /*

            ██████╗ ██╗   ██╗██████╗ ███████╗     ██████╗ ██████╗      ██╗
            ██╔══██╗██║   ██║██╔══██╗██╔════╝    ██╔═══██╗██╔══██╗     ██║
            ██║  ██║██║   ██║██║  ██║█████╗      ██║   ██║██████╔╝     ██║
            ██║  ██║██║   ██║██║  ██║██╔══╝      ██║   ██║██╔══██╗██   ██║
            ██████╔╝╚██████╔╝██████╔╝███████╗    ╚██████╔╝██████╔╝╚█████╔╝
            ╚═════╝  ╚═════╝ ╚═════╝ ╚══════╝     ╚═════╝ ╚═════╝  ╚════╝ 
                                                                          

            */
        var dude = {
            x: '',
            y: '',
            goingU: false,
            goingD: false,
            goingL: false,
            goingR: false,
            inertia: {
                weight: 3,
                speed: 0,
                u: false,
                d: false,
                l: false,
                r: false
            },
            locked: false,
            light: 0,
            start: function() {
                var pos = new Array();
                pos = cave.getStartPos();
                this.x = pos['x'] * blocksize;
                this.y = pos['y'] * blocksize;
            },

            startR: function() {
                var pos = new Array();
                pos = cave.getStartPosR();
                this.x = pos['x'] * blocksize;
                this.y = pos['y'] * blocksize;
            },
            draw: function() {

                // l
                if (this.goingL && this.x > 1 && map[Math.ceil(this.x / blocksize) - 1][Math.round(this.y / blocksize)] == 0) {
                    this.x -= 5;
                    this.inertia.l = true;
                    this.inertia.speed = this.inertia.weight;
                }

                // r
                if (this.goingR && this.x < mapWidth * blocksize && map[Math.floor(this.x / blocksize) + 1][Math.round(this.y / blocksize)] == 0) {
                    this.x += 5;
                    this.inertia.r = true;
                    this.inertia.speed = this.inertia.weight;
                }

                // u
                if (this.goingU && this.y > 1 && map[Math.round(this.x / blocksize)][Math.round(this.y / blocksize) - 1] == 0) {
                    this.y -= 5;
                    this.inertia.u = true;
                    this.inertia.speed = this.inertia.weight;
                }

                // d
                if (this.goingD && this.y < mapHeight * blocksize && map[Math.round(this.x / blocksize)][Math.floor(this.y / blocksize) + 1] == 0) {
                    this.y += 5;
                    this.inertia.d = true;
                    this.inertia.speed = this.inertia.weight;
                }

                // residual inertia and not actively being moved by player
                if (
                    (!this.goingU && !this.goingD && !this.goingL && !this.goingR) && (this.inertia.speed > 0)
                ) {
                    if (this.inertia.l && map[Math.ceil(this.x / blocksize) - 1][Math.round(this.y / blocksize)] == 0) {
                        this.x -= this.inertia.speed;
                    }

                    // r
                    if (this.inertia.r && map[Math.floor(this.x / blocksize) + 1][Math.round(this.y / blocksize)] == 0) {
                        this.x += this.inertia.speed;
                    }

                    // u
                    if (this.inertia.u && map[Math.round(this.x / blocksize)][Math.round(this.y / blocksize) - 1] == 0) {
                        this.y -= this.inertia.speed;
                    }

                    // d
                    if (this.inertia.d && map[Math.round(this.x / blocksize)][Math.floor(this.y / blocksize) + 1] == 0) {
                        this.y += this.inertia.speed;
                    }
                    this.inertia.speed--;
                }
                if (this.inertia.speed <= 0) {
                    this.inertia.u = false;
                    this.inertia.d = false;
                    this.inertia.l = false;
                    this.inertia.r = false;
                }

                context.drawImage(dude_img, this.x, this.y);

                // check if dude moved out of screen

                if (this.x >= (mapWidth * blocksize) - (blocksize)) {
                    // trigger screen change		  		
                    // new map?
                    if (world.pos >= world.mapqty - 1) {

                        // pause game real quick
                        pause();

                        // save current map
                        world.setMap(map);
                        world.pos++;

                        // unset stuff
                        map = [];

                        // generate cave matrix
                        cave.RandomFillmap();
                        cave.MakeCaverns();

                        // clone up some shrooms and initialize them	
                        for (var i = 0; i < shrooms; i++) {
                            shroom_dad[i] = clone(shroom);
                            shroom_dad[i].start();
                        };

                        // initialize PC
                        dude.start();

                        // initialize fireflies		
                        for (var i = 0; i < bugs; i++) {
                            bug_dad[i] = clone(bug);
                            bug_dad[i].start();
                        };

                        // check if portal should be here
                        if (world.pos == 0) {
                            portal.dead = false;
                        } else {
                            portal.dead = true;
                        }

                        // ok, let's go
                        resume();

                    } else {
                        // there is a map already saved to the right

                        // pause game real quick
                        pause();

                        // save current map
                        world.pos++;

                        // unset stuff
                        map = [];

                        map = world.getMap();

                        // clone up some shrooms and initialize them	
                        for (var i = 0; i < shrooms; i++) {
                            shroom_dad[i] = clone(shroom);
                            shroom_dad[i].start();
                        };

                        // initialize PC
                        dude.start();

                        // initialize fireflies		
                        for (var i = 0; i < bugs; i++) {
                            bug_dad[i] = clone(bug);
                            bug_dad[i].start();
                        };

                        // check if portal should be here
                        if (world.pos == 0) {
                            portal.dead = false;
                        } else {
                            portal.dead = true;
                        }

                        // ok, let's go
                        resume();
                    }
                } else if (this.x < blocksize) {
                    // limiting (so can't go left from portal)
                    if (world.pos > 0) {
                        // pause game real quick
                        pause();

                        // save current map
                        world.pos--;

                        // unset stuff
                        map = [];

                        map = world.getMap();

                        // clone up some shrooms and initialize them	
                        for (var i = 0; i < shrooms; i++) {
                            shroom_dad[i] = clone(shroom);
                            shroom_dad[i].start();
                        };

                        // initialize PC
                        dude.startR();

                        // initialize fireflies		
                        for (var i = 0; i < bugs; i++) {
                            bug_dad[i] = clone(bug);
                            bug_dad[i].start();
                        };

                        // check if portal should be here
                        if (world.pos == 0) {
                            portal.dead = false;
                        } else {
                            portal.dead = true;
                        }

                        // ok, let's go
                        resume();
                    }
                }
            },
            shadow: function() {
                // adjust fog of war based on held fireflies
                if (this.light > 0) {
                    var radGrad = context.createRadialGradient(
                        (this.x) + blocksize / 2, (this.y) + blocksize / 2, this.light * 2, (this.x) + blocksize / 2, (this.y) + blocksize / 2, this.light * 10 + 20);
                    radGrad.addColorStop(0, "rgba(50,50,0,0.5)");
                    radGrad.addColorStop(1, "rgba(0,0,0,0.89)");
                } else {
                    var radGrad = 'rgba(0,0,0,0.92)';
                }
                context.fillStyle = radGrad;
                context.fillRect(0, 0, mapWidth * blocksize, mapHeight * blocksize);
            }
        }

/*

███████╗ ██████╗ ██╗   ██╗███╗   ██╗██████╗      ██████╗ ██████╗      ██╗
██╔════╝██╔═══██╗██║   ██║████╗  ██║██╔══██╗    ██╔═══██╗██╔══██╗     ██║
███████╗██║   ██║██║   ██║██╔██╗ ██║██║  ██║    ██║   ██║██████╔╝     ██║
╚════██║██║   ██║██║   ██║██║╚██╗██║██║  ██║    ██║   ██║██╔══██╗██   ██║
███████║╚██████╔╝╚██████╔╝██║ ╚████║██████╔╝    ╚██████╔╝██████╔╝╚█████╔╝
╚══════╝ ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═════╝      ╚═════╝ ╚═════╝  ╚════╝ 


Adapted from Denis Ineshin's Ion.Sound because ain't nobody got time for that
http://ionden.com/a/plugins/ion.sound/en.html
                                                                         
*/

        Sound = function (nam) {
            this.name = nam;
            this.preload = "auto";
            this.loop = false;
            this.paused = false;
            this.sound = null;
            this.callback = null;
            this.init();
        };

        Sound.prototype = {
            init: function () {
                this.sound = new Audio();
                this.sound.src = this.name;
                this.sound.load();
                this.sound.preload = this.preload;
                this.sound.addEventListener("ended", this._ended.bind(this), false);
            },

            play: function (obj) {
                if (!obj) {
                    obj = {};
                }
                if (obj.loop) {
                    if (this.paused) {
                        this._playLoop(this.loop + 1);
                    } else {
                        this._playLoop(obj.loop);
                    }
                } else {
                    this.loop = false;
                    this._play();
                }
                if (obj.onEnded && typeof obj.onEnded === "function") {
                    this.callback = obj.onEnded;
                }
            },

            _play: function () {
                if (this.paused) {
                    this.paused = false;
                } else {
                    try {
                        this.sound.currentTime = 0;
                    } catch (e) {}
                }
                this.sound.play();
            },

            _playLoop: function (loop) {
                if (typeof loop === "boolean") {
                    this.loop = 9999999;
                    this._play();
                } else if (typeof loop === "number") {
                    this.loop = loop - 1;
                    this._play();
                }
            },

            _ended: function () {
                if (this.loop > 0) {
                    this.loop -= 1;
                    this._play();
                }
                if (this.callback) {
                    this.callback(this.name);
                }
            },

            pause: function () {
                this.paused = true;
                this.sound.pause();
            },

            stop: function () {
                this.loop = false;
                this.sound.pause();
                try {
                    this.sound.currentTime = 0;
                } catch (e) {}
            },

            destroy: function () {
                this.stop();
                this.sound.removeEventListener("ended", this._ended.bind(this), false);
                this.sound.src = "";
                this.sound = null;
            }
        };

        /*

        ██╗███╗   ██╗██████╗ ██╗   ██╗████████╗
        ██║████╗  ██║██╔══██╗██║   ██║╚══██╔══╝
        ██║██╔██╗ ██║██████╔╝██║   ██║   ██║   
        ██║██║╚██╗██║██╔═══╝ ██║   ██║   ██║   
        ██║██║ ╚████║██║     ╚██████╔╝   ██║   
        ╚═╝╚═╝  ╚═══╝╚═╝      ╚═════╝    ╚═╝                                          

        */

        document.onkeydown = function(e) {
            switch (e.keyCode) {
                case 37:
                    if (!dude.locked) {
                        dude.goingL = true
                    };
                    break;
                case 39:
                    if (!dude.locked) {
                        dude.goingR = true
                    };
                    break;
                case 38:
                    if (!dude.locked) {
                        dude.goingU = true
                    };
                    break;
                case 40:
                    if (!dude.locked) {
                        dude.goingD = true
                    };
                    break;
            }

            switch (String.fromCharCode(e.keyCode)) {
                case 'I':
                    if (!paused) {
                        setTimeout(function() { pause(); }, 100);
                        setTimeout(function() { score.draw(); }, 500);
                    } else {
                        resume();
                    }
                    break;
                case ' ':
                    resume();
                    break;
            }
        };

        document.onkeyup = function(e) {
            switch (e.keyCode) {
                case 37:
                    dude.goingL = false;
                    break;
                case 39:
                    dude.goingR = false;
                    break;
                case 38:
                    dude.goingU = false;
                    break;
                case 40:
                    dude.goingD = false;
                    break;
            }
        };

        /*

        ██╗    ██╗ ██████╗ ██████╗ ██╗  ██╗███████╗██████╗ ███████╗
        ██║    ██║██╔═══██╗██╔══██╗██║ ██╔╝██╔════╝██╔══██╗██╔════╝
        ██║ █╗ ██║██║   ██║██████╔╝█████╔╝ █████╗  ██████╔╝███████╗
        ██║███╗██║██║   ██║██╔══██╗██╔═██╗ ██╔══╝  ██╔══██╗╚════██║
        ╚███╔███╔╝╚██████╔╝██║  ██║██║  ██╗███████╗██║  ██║███████║
         ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚══════╝

        */


        function degradeFireflies() {
        	if( !dialogs['fireflydie'] && dude.light>0) {
	        	
	        	dialogs['fireflydie'] = true;
	        	setTimeout(function() { pause(); }, 100);
	        	setTimeout(function() { dialog.draw("One of the fireflies stopped glowing\n\n...It looks like they die if I hold them too long."); }, 300);
	        }
        	if(dude.light>0) {
        		dude.light -= 1;
        		score.fireflies = dude.light;
        	}

        }

        function conductor() {
            // bg
            cave.MakeBG();

            // all shrooms
            for (var i = 0; i < shrooms; i++) {
                shroom_dad[i].draw();
            };

            // portal in off position
            if (portal.off) {
                portal.draw()
            };


            if (world.pos == 1) {
            	stasis.start();
            	stasis.draw();
            }


            // cave walls
            cave.printwall();

            // global shadow
            dude.shadow();

            // portal in on position
            if (!portal.off) {
                portal.draw()
            };


            // show dude
            dude.draw();

            // draw fireflies
            for (var i = 0; i < bugs; i++) {
                bug_dad[i].wander();
                bug_dad[i].shadow();
            };

            // portal glow
            portal.shadow();

            // draw dark top of walls
            cave.printmap();

        }

        function pause() {
            paused = true;
            dude.locked = true;
            clearInterval(conductorInterval);
            clearInterval(degradeFirefliesInterval);
        }

        function resume() {
            paused = false;
            dude.locked = false;
            conductorInterval = setInterval(conductor, 40);
            degradeFirefliesInterval = setInterval(degradeFireflies, 10000);
        }


        /*

        ██╗   ██╗ █████╗ ██████╗ ███████╗
        ██║   ██║██╔══██╗██╔══██╗██╔════╝
        ██║   ██║███████║██████╔╝███████╗
        ╚██╗ ██╔╝██╔══██║██╔══██╗╚════██║
         ╚████╔╝ ██║  ██║██║  ██║███████║
          ╚═══╝  ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝
                                         
        */
        var map = new Array();
        var mapHeight = 40;
        var mapWidth = 80;
        var PercentAreWalls = 50;
        var itteration = 0;
        var maxitteration = 7;
        var blocksize = 10;
        var canv;
        var context;
        var paused = false;
        var dude_img = new Image();
        dude_img.src = 'ghost3.png';

        var bug_img = new Image();
        bug_img.src = 'fly.png';

        var bug_dad = new Array();
        var bugs = 5;

        var shroom_img = new Image();
        shroom_img.src = 'shroom2.png';

        var shroom_dad = new Array();
        var shrooms = 5;

        var portal_img = new Image();
        portal_img.src = 'portal2.png';

        var stasis_img = new Image();
        stasis_img.src = 'stasis.png';

        var conductorInterval;
        var degradeFirefliesInterval;

        var dialogs = new Array();

        var bgmusic = new Sound('bg3.mp3');

        var pickupsound = new Sound('pickup.mp3');
        var blip = new Sound('blip.mp3');



    </script>
    <style>
        body {
            background-color: #000;
            color: #abc;
        }
    </style>
</head>

<body>
    <canvas id="canv"></canvas>
    <pre>
arrow keys to move
'i' key to view inventory
</pre>
</body>

</html>
