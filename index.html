<!DOCTYPE html>
<html>
<head>
	<title></title>
	<script>

/*
-----------------------------------
-- Rough spitballing of the plot --
-----------------------------------

so

you are a ghost in a chunk of dead planet flying through space

you grow mushrooms that generate light

you need light to explore the cave, the more you spread the mushrooms out the more of the cave is lit up

maybe something becomes apparent as you light up more and more
i think you're on to something

there might be old doors or something from the old world that only respond to light (since you are a ghost) so you literally can't progress until you have a room lit up


facus
that flavor text

hahaha

ghost mining space mushrooms

from the inside of an asteroid
hm
damn
that's actually good
that sounds like a rich-ass story

instead of a ghost maybe your just a person in a little capsule

like a little mining ship
OR A GHOST THAT IS RIDING A CHUNK OF YOUR RUINED PLANET

lol

yessss
basically the final fantasy movie

ooooh

so

you are a ghost in a chunk of dead planet flying through space

you grow mushrooms that generate light

you need light to explore the cave, the more you spread the mushrooms out the more of the cave is lit up

maybe something becomes apparent as you light up more and more
i think you're on to something

there might be old doors or something from the old world that only respond to light (since you are a ghost) so you literally can't progress until you have a room lit up
this is gold
FUCKING GOLD
it was originally meant to be in space
but generating proceedural spaceship is not ez

well the design lends itself to being the inside of a floating chunk of planet

as you progress it could become more and more structured, like eventually being halls and such?

hmm
20 minutes ago
whoo boy
got fluid movement

:oooo
and you can now collect mushrooms
and increment a score
and i fixed the problems with you being isolated in a little cave somewhere

i need to add inertia to the movement
and make the fireflies move fluidly... which means i have to rewrite their wandering function
and I'm 100% going to go with your idea about the plot


:D:D

so you wander around, eventually you find a lab which a bunch of crycells and stuff in it. The big reveal is that you are in a chunk of the moon or something. It was blown up to provide the thrust to start the chunk on its path to a new system because the sun was dying or something. Low-tech spaceship
i think i was going to go bleaker

just a single ghost, alone on a chunk of blown up planet?

*in*

not on
you're dead and you need to collect enough chunks of soul containing mushrooms to piece together a plausible phantasy of companionship
and winning is basically giving up being a ghost because you're content
and fizzling out
*fantasy
i mean, i can replace the ghost with a dude and do your idea instead
still kinda fleshing it out

I mean you would be a ghost

it would still be kind of dark because your still alone

there are living people, but they are in cryo

it would be more like a reveal
or maybe you left your cryo'd body to fix up the ship as a ghost

like you could have been a tech working in the cryo facility before the explosion or something
because lifesupport/engine/nav is dying

I mean it should start out with you not really knowing why ou are the way you are

you don't remember who you used to be

and don't know where you are

ooooh duuuuude

you are the ghost of the biocomputer that ran the facility
and you realize that you need to fix the reactor or something or else your body and friends will die

it was run by a living person plugged in to it
oh, that's not bad

you want dark, thats dark

everything already failed

they are all dead

the mission failed
and your motivation is what?

so

hear this out
the sad andriod everafter?

you kind of "come to" in a dark cave, you are ethereal

it doesn't make sense, but whatever maybe I Should start exploring to see waht is going on

you explore and collect mushrooms (for some reason you can interact with mushrooms and fireflies, due to some stupid reason)

as you explore more and more you start finding hallways and stuff

finally you get to the heart of a facility that has crychambers and then one large tube with a person hanging limply inside of it

similar to this

http://static.comicvine.com/uploads/original/10/100757/1963130-melfina25.jpg
im getting excited for pixel art

but everything is shutting down

then you realize you are the person in the tube, you are the computer thats supposed to manage it during its long flight

but due to something going wrong, your life support or something broke so you died

maybe you can mount a last ditch effort to save the machines

and then you can keep a solemn guard as a ghost

the eternal ephemeral sentinel
ok, extending that idea.... the mushrooms contain radioisotopes that they leeched out of the rock... you need enough of them to get a little more life out of the computer in an attempt to upload the minds of your crew so they can be put into space-computer-ghosts with you
like, approximate it from their dead brains

oooh, yeah. The mission could be blown entirely. You realize there is no way to continue, so instead you decide to try and make everyone post-physical
yeah
now that, i like
it's dark, but also cute
and honestly, who really thinks an asteriod is going to reach a habitable planet and things will be happily ever after, anyway...
kinda better that way

well, it was a long shot. But it was either try or die
rite, but everyone's dead anyway
so why not ghost-chill

heh
HOLY SHIT
THE MONEYSHOT
FINAL CREDITS IS A BUNCH OF GHOSTS ADMIRING THE FIREFLIES
FROM LIKE OVER THE SHOULDER PERSPECTIVE
WITH THE STARS TWINKLIN AND SHIT

hahaha
it's a fucking masterpiece
legit



*/



// http://patorjk.com/software/taag/#p=display&f=ANSI%20Shadow&t=VARS

/*

██╗   ██╗ █████╗ ██████╗ ███████╗
██║   ██║██╔══██╗██╔══██╗██╔════╝
██║   ██║███████║██████╔╝███████╗
╚██╗ ██╔╝██╔══██║██╔══██╗╚════██║
 ╚████╔╝ ██║  ██║██║  ██║███████║
  ╚═══╝  ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝
                                 
*/
	var map = new Array();
	var mapHeight = 40;
	var mapWidth = 80;
	var PercentAreWalls = 50;
	var itteration = 0;
	var maxitteration = 7;
	var blocksize=10;
	var canv;
	var context;
	var paused = false;
	var dude_img = new Image();
	dude_img.src = 'ghost3.png';

	var bug_img = new Image();
	bug_img.src = 'fly.png';

	var bug_dad = new Array();
	var bugs = 5;

	var shroom_img = new Image();
	shroom_img.src = 'shroom2.png';

	var shroom_dad = new Array();
	var shrooms = 5;

	var portal_img = new Image();
	portal_img.src = 'portal2.png';

	var conductorInterval;
	var bugInterval;
/*

██╗  ███╗   ██╗  ██╗ ████████╗
██║  ████╗  ██║  ██║ ╚══██╔══╝
██║  ██╔██╗ ██║  ██║    ██║   
██║  ██║╚██╗██║  ██║    ██║   
██║  ██║ ╚████║  ██║    ██║   
╚═╝  ╚═╝  ╚═══╝  ╚═╝    ╚═╝   


*/

	document.addEventListener("DOMContentLoaded", function(event) {
		canv = document.getElementById("canv");
		context = canv.getContext("2d");

		canv.setAttribute('width', mapWidth*blocksize);
		canv.setAttribute('height', mapHeight*blocksize);

		// init sequence

		// generate cave matrix
		cave.RandomFillmap(); 
		cave.MakeCaverns();

		// clone up some shrooms and initialize them	
		for (var i = 0; i < shrooms; i++) {
			shroom_dad[i] = clone(shroom);
			shroom_dad[i].start();
		};
	
		// initialize PC
		dude.start();

		portal.start();
		// initialize fireflies		
		for (var i = 0; i < bugs; i++) {
			bug_dad[i] = clone(bug);
			bug_dad[i].start();
		};
		
		// start up big timer
		resume();

	});
		
	function clone(obj) {
	    if(obj == null || typeof(obj) != 'object')
	        return obj;

	    var temp = obj.constructor(); // changed

	    for(var key in obj) {
	        if(obj.hasOwnProperty(key)) {
	            temp[key] = clone(obj[key]);
	        }
	    }
	    return temp;
	}

/*

 ██████╗ █████╗ ██╗   ██╗███████╗     ██████╗ ██████╗      ██╗
██╔════╝██╔══██╗██║   ██║██╔════╝    ██╔═══██╗██╔══██╗     ██║
██║     ███████║██║   ██║█████╗      ██║   ██║██████╔╝     ██║
██║     ██╔══██║╚██╗ ██╔╝██╔══╝      ██║   ██║██╔══██╗██   ██║
╚██████╗██║  ██║ ╚████╔╝ ███████╗    ╚██████╔╝██████╔╝╚█████╔╝
 ╚═════╝╚═╝  ╚═╝  ╚═══╝  ╚══════╝     ╚═════╝ ╚═════╝  ╚════╝ 
                                                              

*/
var cave = {
	MakeCaverns: function()
	{
		for(itteration=0; itteration <= maxitteration; itteration++) {
			for(var row=0; row <= mapHeight; row++) {
				for(var column = 0; column <= mapWidth; column++) {
					map[column][row] = this.PlaceWallLogic(column,row);
				}
			}
		}
	},

	RandomFillmap: function()
	{
		var mapMiddle = 0;
		var column;
		var row;

		for (column = 0; column <= mapWidth; column++) {
			// add new dimension
			map[column] = new Array();
			mapMiddle = (mapHeight / 2);
			for (row = 0; row <= mapHeight; row++) {
				if(column == 0 && row >= mapMiddle + 10 && row <= mapMiddle - 10) {
					map[column][row] = 1;
				} else if (row == 0) {
					map[column][row] = 1;
				} else if (column == mapWidth-1 && row >= mapMiddle + 10 && row <= mapMiddle - 10) {
					map[column][row] = 1;
				} else if (row == mapHeight-1) {
					map[column][row] = 1;
				}
				// Else, fill with a wall a random percent of the time
				else {
					if(row <= mapMiddle + 2 && row >= mapMiddle - 2) {
						map[column][row] = 0;
					} else {
						map[column][row] = this.RandomPercent(PercentAreWalls);
					}
				}
			};
		};
	},
	
	RandomPercent: function(percent)
	{
		if(percent>= (Math.random() * 101) +1) {
			return 1;
		}
		return 0;
	},

	PlaceWallLogic: function(x, y)
	{
		var numWalls = this.GetAdjacentWalls(x,y,1,1);
 
		if(map[x][y]==1) {
			if( numWalls >= 4 ) {
				return 1;
			}
			if(numWalls<2) {
				return 0;
			}
		} else {
			if(numWalls>=5) {
				return 1;
			}
		}
		return 0;
	},

	GetAdjacentWalls: function( x, y, scopeX, scopeY)
	{
		var startX = x - scopeX;
		var startY = y - scopeY;
		var endX = x + scopeX;
		var endY = y + scopeY;
 
		var iX = startX;
		var iY = startY;
 
		var wallCounter = 0;
 
		for(iY = startY; iY <= endY; iY++) {
			for(iX = startX; iX <= endX; iX++)
			{
				if(!(iX==x && iY==y))
				{
					if(this.IsWall(iX,iY))
					{
						wallCounter += 1;
					}
				}
			}
		}
		return wallCounter;
	},
 
	IsWall: function(x,y)
	{
		// Consider out-of-bound a wall
		if( this.IsOutOfBounds(x,y) )
		{
			return true;
		}
 
		if( map[x][y]==1	 )
		{
			return true;
		}
 
		if( map[x][y]==0	 )
		{
			return false;
		}
		return false;
	},
 
	IsOutOfBounds: function(x, y)
	{
		if( x<0 || y<0 )
		{
			return true;
		}
		else if( x>mapWidth-1 || y>mapHeight-1 )
		{
			return true;
		}
		return false;
	},

	printmap: function() 
	{	
		var outp = '';
		for (var y = 0; y <= mapHeight; y++) {
			for (var x = 0; x <= mapWidth; x++) {
				if (map[x][y] == 1) {
					context.fillStyle="#234";
					context.fillRect(x*blocksize, y*blocksize, blocksize, blocksize);
				} else {
					context.fillStyle="#9ab";
					context.fillRect(x*blocksize, y*blocksize, blocksize, blocksize);
				}
			};
		};
	},

	getStartPos: function() 
	{
		var pos = new Array();
		for (var x = 2; x <= mapWidth; x++) {
			if (map[x][Math.floor(mapHeight/2)] == 0) {
				pos['x'] = x;
				pos['y'] = Math.floor(mapHeight/2);
				return pos;
			}
		};
	},

	getRandPos: function () 
	{
		var pos = new Array();
		var i = 0;
		for (var x = 0; x <= mapWidth; x++) {
			for (var y = 0; y <= mapHeight; y++) {
				if (map[x][y] == 0) {
					pos[i] = new Array();
					pos[i]['x'] = x;
					pos[i]['y'] = y;
					i++;
				}
			};
		};

		var ret = pos[Math.floor(Math.random() * pos.length)]
		return ret;
	}
};

/*

███████╗ ██████╗ ██████╗ ██████╗ ███████╗     ██████╗ ██████╗      ██╗
██╔════╝██╔════╝██╔═══██╗██╔══██╗██╔════╝    ██╔═══██╗██╔══██╗     ██║
███████╗██║     ██║   ██║██████╔╝█████╗      ██║   ██║██████╔╝     ██║
╚════██║██║     ██║   ██║██╔══██╗██╔══╝      ██║   ██║██╔══██╗██   ██║
███████║╚██████╗╚██████╔╝██║  ██║███████╗    ╚██████╔╝██████╔╝╚█████╔╝
╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝     ╚═════╝ ╚═════╝  ╚════╝ 
                                                                      
*/

var score = {
	shrooms: 0,
	fireflies: 0,
	width: 200,
	height: 200,
	x: 300,
	y: 100,
	draw: function() {
		

		// inventory box
		context.rect(this.x,this.y,this.width,this.height);
		context.strokeStyle = '#000';
		context.linewidth = 10;
		context.stroke();
		context.fillStyle="rgba(100,150,200,0.8)";
		context.fill();

		// items title
		context.font="16px Courier New";
		context.fillStyle = 'white';
		context.fillText('ITEMS', this.x+72, this.y+20);


		//shrooms
		context.drawImage(shroom_img,this.x+20, this.y + 50);
		context.fillText(this.shrooms, this.x+40, this.y+60);

		//fireflies
	
		var fireflyx = this.x+20;
		var fireflyy = this.y+80;
		var radGrad = context.createRadialGradient(
    	fireflyx+blocksize/2, fireflyy+blocksize/2, 10, 
    	fireflyx+blocksize/2, fireflyy+blocksize/2, 40);
		radGrad.addColorStop(0, "rgba(229,255,160,0.15)");
		radGrad.addColorStop(1, "transparent");

		context.fillStyle = radGrad;
        context.fillRect(0, 0, mapWidth*blocksize, mapHeight*blocksize);

		context.drawImage(bug_img, fireflyx, fireflyy);
		context.fillStyle = 'white';
		context.fillText(this.fireflies, this.x+40, this.y+90);
	}
};



/*

███████╗██╗  ██╗██████╗  ██████╗  ██████╗ ███╗   ███╗     ██████╗ ██████╗      ██╗
██╔════╝██║  ██║██╔══██╗██╔═══██╗██╔═══██╗████╗ ████║    ██╔═══██╗██╔══██╗     ██║
███████╗███████║██████╔╝██║   ██║██║   ██║██╔████╔██║    ██║   ██║██████╔╝     ██║
╚════██║██╔══██║██╔══██╗██║   ██║██║   ██║██║╚██╔╝██║    ██║   ██║██╔══██╗██   ██║
███████║██║  ██║██║  ██║╚██████╔╝╚██████╔╝██║ ╚═╝ ██║    ╚██████╔╝██████╔╝╚█████╔╝
╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚═╝     ╚═╝     ╚═════╝ ╚═════╝  ╚════╝ 
                                                                                  

*/

	var shroom = {
	  	x: "", 
	  	y: "",
	  	dead: false, 
	  	start: function(){
	    	var pos = new Array();
			pos = cave.getRandPos();
			this.x = pos['x'];
			this.y = pos['y'];
	  	},
	  	draw: function() {
	  		if( Math.round(dude.x/blocksize) == this.x && Math.round(dude.y/blocksize) == this.y && !this.dead) {
	  			this.dead = true;
	  			score.shrooms++;
	  		}
	  		if(!this.dead) {
				context.drawImage(shroom_img,this.x * blocksize, this.y * blocksize);
			}
	  	}
	}

//------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------

	var portal = {
	  	x: "", 
	  	y: "",
	  	off: false,
	  	dead: false,
	  	glow: 0.8,
	  	maxglow:0.30,
	  	minglow:0.1,
	  	glowup: true,
	  	start: function(){
			this.x = dude.x - blocksize;
			this.y = dude.y - blocksize;
	  	},
	  	draw: function() {
	  		if(this.dead) {
	  			return;
	  		}

	  		if(dude.x > this.x + 50 || dude.x < this.x - 50 || dude.y < this.y - 50 || dude.y > this.y + 50) {
	  			portal_img.src = 'portaldead.png';
	  			this.off = true;
	  		}

	  		if(!this.off) {


		  		var radGrad = context.createRadialGradient(
		    	(this.x)+(blocksize*1.5), (this.y)+(blocksize*1.5), 2, 
		    	(this.x)+(blocksize*1.5), (this.y)+(blocksize*1.5), 20);
				radGrad.addColorStop(0, "rgba(0,255,255,"+this.glow+")");
				radGrad.addColorStop(1, "transparent");

				context.fillStyle = radGrad;
		        context.fillRect(0, 0, mapWidth * blocksize, mapHeight * blocksize);

		        if(this.glowup) {
		        	this.glow += 0.01;
		        } else {
		        	this.glow -= 0.01;
		        }

		        if(this.glow > this.maxglow) {
		        	this.glowup = false;
		        }
		        if(this.glow < this.minglow) {
		        	this.glowup = true;
		        }
		    }
			context.drawImage(portal_img,this.x, this.y);
	  	}
	}



/*

██████╗ ██╗   ██╗ ██████╗      ██████╗ ██████╗      ██╗
██╔══██╗██║   ██║██╔════╝     ██╔═══██╗██╔══██╗     ██║
██████╔╝██║   ██║██║  ███╗    ██║   ██║██████╔╝     ██║
██╔══██╗██║   ██║██║   ██║    ██║   ██║██╔══██╗██   ██║
██████╔╝╚██████╔╝╚██████╔╝    ╚██████╔╝██████╔╝╚█████╔╝
╚═════╝  ╚═════╝  ╚═════╝      ╚═════╝ ╚═════╝  ╚════╝ 
                                                       
*/

	var bug = {
	  	x: '', 
	  	y: '', 
	  	goingU: false,
	  	goingD: false,
	  	goingL: false,
		goingR: false,
		inertia: {weight: 5, speed: 0, u: false, d: false, l: false, r:false},
		increment: 0.5,
		dead: false,

	  	start: function(){
	    	var pos = new Array();
			pos = cave.getRandPos();
			this.x = pos['x']*blocksize;
			this.y = pos['y']*blocksize;
	  	},

	  	draw: function() {	  

	  		if( Math.round(dude.x/blocksize) == Math.round(this.x/blocksize) && Math.round(dude.y/blocksize) == Math.round(this.y/blocksize) && !this.dead) {
	  			this.dead = true;
	  			score.fireflies++;
	  			dude.light++;
	  		}

	  		if(this.dead) {
	  			return;
	  		}
	  		// l
	  		if(this.goingL && this.x > 1 && map[Math.ceil(this.x/blocksize)-1][Math.round(this.y/blocksize)]==0) {
	  			this.x -= this.increment;
	  			this.inertia.l = true;
	  			this.inertia.speed = this.inertia.weight;
	  		}

		  	// r
	  		if(this.goingR && this.x < mapWidth*blocksize && map[Math.floor(this.x/blocksize)+1][Math.round(this.y/blocksize)]==0) {
	  			this.x += this.increment;
	  			this.inertia.r = true;
	  			this.inertia.speed = this.inertia.weight;
	  		}
		  		
		  	// u
			if(this.goingU && this.y > 1 && map[Math.round(this.x/blocksize)][Math.round(this.y/blocksize)-1]==0) {
		  		this.y -= this.increment;
		  		this.inertia.u = true;
		  		this.inertia.speed = this.inertia.weight;
		  	}

		  	// d
		  	if(this.goingD && this.y < mapHeight*blocksize && map[Math.round(this.x/blocksize)][Math.floor(this.y/blocksize)+1]==0) {
		  		this.y += this.increment;
		  		this.inertia.d = true;
		  		this.inertia.speed = this.inertia.weight;
		  	}

		  	// residual inertia
		  	if(
		  		(!this.goingU && !this.goingD && !this.goingL && !this.goingR) 
		  		&& (this.inertia.speed > 0 ) 
		  	) {
		  		if(this.inertia.l && this.x > 1 && map[Math.ceil(this.x/blocksize)-1][Math.round(this.y/blocksize)]==0) {
	  				this.x -= this.inertia.speed;
	  			}

			  	// r
		  		if(this.inertia.r && this.x < mapWidth*blocksize && map[Math.floor(this.x/blocksize)+1][Math.round(this.y/blocksize)]==0) {
		  			this.x += this.inertia.speed;
		  		}
			  		
			  	// u
				if(this.inertia.u && this.y > 1 && map[Math.round(this.x/blocksize)][Math.round(this.y/blocksize)-1]==0) {
			  		this.y -= this.inertia.speed;
			  	}

			  	// d
			  	if(this.inertia.d && this.y < mapHeight*blocksize && map[Math.round(this.x/blocksize)][Math.floor(this.y/blocksize)+1]==0) {
			  		this.y += this.inertia.speed;
			  	}
		  		this.inertia.speed--;
		  	}
		  	if(this.inertia.speed <= 0) {
		  		this.inertia.u = false;
		  		this.inertia.d = false;
		  		this.inertia.l = false;
		  		this.inertia.r = false;
		  	}

 			var radGrad = context.createRadialGradient(
	    	(this.x)+blocksize/2, (this.y)+blocksize/2, 10, 
	    	(this.x)+blocksize/2, (this.y)+blocksize/2, 40);
			radGrad.addColorStop(0, "rgba(229,255,160,0.15)");
			radGrad.addColorStop(1, "transparent");

			context.fillStyle = radGrad;
	        context.fillRect(0, 0, mapWidth * blocksize, mapHeight * blocksize);

			context.drawImage(bug_img,this.x, this.y);
	  	},

	  	wander: function() {
	  		// reset movement


	  		// start random movement
	  		var direction = Math.floor(Math.random() * 10);
			switch(direction) {
				case 0:
					this.goingD = false;
					this.goingU = true;
					break;
				case 1:
					this.goingU = false;

					this.goingD = true;
					break;
				case 2:
	  				this.goingR = false;
					this.goingL = true;
					break;
				case 3:
			  		this.goingL = false;
					this.goingR = true;
					break;
			}
			this.draw();
		}	
	}

/*

██████╗ ██╗   ██╗██████╗ ███████╗     ██████╗ ██████╗      ██╗
██╔══██╗██║   ██║██╔══██╗██╔════╝    ██╔═══██╗██╔══██╗     ██║
██║  ██║██║   ██║██║  ██║█████╗      ██║   ██║██████╔╝     ██║
██║  ██║██║   ██║██║  ██║██╔══╝      ██║   ██║██╔══██╗██   ██║
██████╔╝╚██████╔╝██████╔╝███████╗    ╚██████╔╝██████╔╝╚█████╔╝
╚═════╝  ╚═════╝ ╚═════╝ ╚══════╝     ╚═════╝ ╚═════╝  ╚════╝ 
                                                              

*/

	var dude = {
	  	x: '', 
	  	y: '', 
	  	goingU: false,
	  	goingD: false,
	  	goingL: false,
		goingR: false,
		inertia: {weight: 3, speed: 0, u: false, d: false, l: false, r:false},
		locked: false,
		light: 0,
	  	start: function(){
	    	var pos = new Array();
			pos = cave.getStartPos();
			this.x = pos['x']*blocksize;
			this.y = pos['y']*blocksize;
	  	},
	
	  	draw: function() {
	  		
	  		// l
	  		if(this.goingL && this.x > 1 && map[Math.ceil(this.x/blocksize)-1][Math.round(this.y/blocksize)]==0) {
	  			this.x -= 5;
	  			this.inertia.l = true;
	  			this.inertia.speed = this.inertia.weight;
	  		}

		  	// r
	  		if(this.goingR && this.x < mapWidth*blocksize && map[Math.floor(this.x/blocksize)+1][Math.round(this.y/blocksize)]==0) {
	  			this.x += 5;
	  			this.inertia.r = true;
	  			this.inertia.speed = this.inertia.weight;
	  		}
		  		
		  	// u
			if(this.goingU && this.y > 1 && map[Math.round(this.x/blocksize)][Math.round(this.y/blocksize)-1]==0) {
		  		this.y -= 5;
		  		this.inertia.u = true;
		  		this.inertia.speed = this.inertia.weight;
		  	}

		  	// d
		  	if(this.goingD && this.y < mapHeight*blocksize && map[Math.round(this.x/blocksize)][Math.floor(this.y/blocksize)+1]==0) {
		  		this.y += 5;
		  		this.inertia.d = true;
		  		this.inertia.speed = this.inertia.weight;
		  	}

		  	// residual inertia and not actively being moved by player
		  	if(
		  		(!this.goingU && !this.goingD && !this.goingL && !this.goingR) 
		  		&& (this.inertia.speed > 0 ) 
		  	) {
		  		if(this.inertia.l && this.x > 1 && map[Math.ceil(this.x/blocksize)-1][Math.round(this.y/blocksize)]==0) {
	  				this.x -= this.inertia.speed;
	  			}

			  	// r
		  		if(this.inertia.r && this.x < mapWidth*blocksize && map[Math.floor(this.x/blocksize)+1][Math.round(this.y/blocksize)]==0) {
		  			this.x += this.inertia.speed;
		  		}
			  		
			  	// u
				if(this.inertia.u && this.y > 1 && map[Math.round(this.x/blocksize)][Math.round(this.y/blocksize)-1]==0) {
			  		this.y -= this.inertia.speed;
			  	}

			  	// d
			  	if(this.inertia.d && this.y < mapHeight*blocksize && map[Math.round(this.x/blocksize)][Math.floor(this.y/blocksize)+1]==0) {
			  		this.y += this.inertia.speed;
			  	}
		  		this.inertia.speed--;
		  	}
		  	if(this.inertia.speed <= 0) {
		  		this.inertia.u = false;
		  		this.inertia.d = false;
		  		this.inertia.l = false;
		  		this.inertia.r = false;
		  	}

		  	// adjust fog of war based on held fireflies

		  	if(this.light > 0) {
				var radGrad = context.createRadialGradient(
	    		(this.x)+blocksize/2, (this.y)+blocksize/2, this.light*2, 
	    		(this.x)+blocksize/2, (this.y)+blocksize/2, this.light*10+20);
				radGrad.addColorStop(0, "rgba(0,25,50,0.4)");
				radGrad.addColorStop(1, "rgba(0,25,50,0.95)");
			} else {
				var radGrad = 'rgba(0,25,50,0.99)';
			}
			
			context.drawImage(dude_img, this.x, this.y);
		
			context.fillStyle = radGrad;
			context.fillRect(0, 0, mapWidth * blocksize, mapHeight * blocksize);
			context.drawImage(dude_img, this.x, this.y);

	  	}

	}

/*

██╗███╗   ██╗██████╗ ██╗   ██╗████████╗
██║████╗  ██║██╔══██╗██║   ██║╚══██╔══╝
██║██╔██╗ ██║██████╔╝██║   ██║   ██║   
██║██║╚██╗██║██╔═══╝ ██║   ██║   ██║   
██║██║ ╚████║██║     ╚██████╔╝   ██║   
╚═╝╚═╝  ╚═══╝╚═╝      ╚═════╝    ╚═╝                                          

*/

	
	document.onkeydown = function (e) {    
		switch(e.keyCode) {
			case 37:
				if(!dude.locked) {dude.goingL = true};
				break;
			case 39:
				if(!dude.locked) {dude.goingR = true};
				break;
			case 38:
				if(!dude.locked) {dude.goingU = true};
				break;
			case 40:
				if(!dude.locked) {dude.goingD = true};
				break;
		}

		switch(String.fromCharCode(e.keyCode)) {
			case 'I':
				if(!paused) {
					pause();
					score.draw();

				} else {
					resume();
				}
				break;
			case ' ':
				resume();
				break;
		}
	};

	document.onkeyup = function (e) {    
		switch(e.keyCode) {
			case 37:
				dude.goingL = false;
				break;
			case 39:
				dude.goingR = false;
				break;
			case 38:
				dude.goingU = false;
				break;
			case 40:
				dude.goingD = false;
				break;
		}
	};

/*

██╗    ██╗ ██████╗ ██████╗ ██╗  ██╗███████╗██████╗ ███████╗
██║    ██║██╔═══██╗██╔══██╗██║ ██╔╝██╔════╝██╔══██╗██╔════╝
██║ █╗ ██║██║   ██║██████╔╝█████╔╝ █████╗  ██████╔╝███████╗
██║███╗██║██║   ██║██╔══██╗██╔═██╗ ██╔══╝  ██╔══██╗╚════██║
╚███╔███╔╝╚██████╔╝██║  ██║██║  ██╗███████╗██║  ██║███████║
 ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚══════╝

*/


	//var bugInterval = setInterval(function(){ bugwander() }, 1000);


	function wanderBugs() {
		for (var i = 0; i < bugs; i++) {	
			bug_dad[i].wander();
		};		
	}
	
	function conductor(){
			cave.printmap();
			
			for (var i = 0; i < shrooms; i++) {
				shroom_dad[i].draw();
			};
			
			dude.draw();
			portal.draw();
			for (var i = 0; i < bugs; i++) {	
				bug_dad[i].wander();
			};	

			
	
	}


	function pause() {
		paused = true;
		dude.locked = true;
		clearInterval(conductorInterval);
		clearInterval(bugInterval);
	}

	function resume() {
		paused = false;
		dude.locked = false;
		conductorInterval = setInterval(conductor, 40);
		//bugInterval = setInterval(wanderBugs, 160);
	}


</script>
<style>
body {
	background-color:#000;
	color:#abc;
}
</style>
</head>
<body>
<canvas id="canv"></canvas>

<pre>
-- TODO ---------------
------------------------

[nuts and bolts]
	- fine tune dude collision and pickup boxes
 	- create more random cave features
 	- make cave like a path and moving off screen indexes to another cave (LoZ)
 	- make some dialog box functions for speech and/or messages
 	- make a start screen
 	- probably split the cave.draw into just walls and then another one for the bg pane 
 	  so any places objects don't overlap the walls
 	- split off player fog of war into it's own method/class so I can have more control over layers
[conceptual]
	- reduce player vision, increase fireflie vision?
	- collect fireflies to increase player vision?
</pre>

</body>
</html>